import numpy.typing as npt

import numpy as np
from scipy.special import jv, jn_zeros, jnp_zeros

import torch
from torch import nn
from imitation_learning.model.modules.harmonics.harmonics import HarmonicFunction
from imitation_learning.model.modules.harmonics import bessel, grid

def get_n(Nmax: int) -> npt.NDArray:
    """ Returns an array of n up to Nn.

    Args:
       NMax - Maximum n.
    """
    return np.arange(Nmax+1)[1:]

def get_m(Nm: int) -> npt.NDArray:
    """ Returns m for the 1D angular polar components.

    Args:
        Nm - Length of phi grid.
    """
    m = np.arange(Nm)
    condition = np.where(m > float(Nm) / 2.)[0]
    m[condition] -= Nm
    return m

def get_knm(xnm: npt.NDArray, Rmax: float) -> npt.NDArray:
    """ Returns the Fouirer Mode k components given the zeros and maximum radius

    Args:
        xnm - Location of zeros.
        Rmax: Maximum radius.
    """
    return xnm / Rmax

def get_Nnm_zero(m: int, xnm: npt.NDArray, Rmax: float) -> npt.NDArray:
    """ Returns the normalization constant for zero-value boundaries.

    Args:
        m - Order.
        xnm - Location of zeros for zero-value boundaries.
        Rmax - Maximum radius.
    """
    Nnm = ((Rmax**2.)/2.)*(bessel.get_Jm(m+1, xnm)**2.)
    return Nnm

def get_Nnm_deri(m: int, xnm: npt.NDArray, Rmax: float) -> npt.NDArray:
    """ Returns the normalization constant for derivative boundaries.

    Args:
        m - Order
        xnm - Location of zeros for derivative boundaries.
        Rmax - Maximum radius.
    """
    return ((Rmax**2.)/2.)*(1. - (m**2.)/(xnm**2.))*(bessel.get_Jm(m, xnm)**2.)

def get_Rnm(r: npt.NDArray, m: int, knm: float, Nnm: float) -> npt.NDArray:
    """ Radial component of the polar basis function.

    Args:
        r - Radial values.
        m - Order.
        knm - Corresponding k Fourier mode for n and m.
        Nnm - Corresponding normalisation constant.
    """
    return (1./np.sqrt(Nnm))*bessel.get_Jm(m, knm*r)

def get_Phi_m(m: int, phi: npt.NDArray) -> npt.NDArray:
    """ Angular component of the polar basis function.

    Args:
        m - Order.
        phi - Angular values (radians).
    """
    if m == 0:
        return np.ones_like(phi) / np.sqrt(2*np.pi)
    else:
        return [np.cos(m * phi) / np.sqrt(2*np.pi), np.sin(m * phi)/ np.sqrt(2*np.pi)]

def get_Psi_nm(n: int, m: int, r: npt.NDArray, phi: npt.NDArray, knm: float, Nnm: npt.NDArray) -> npt.NDArray:
    """ Polar radial basis function
    Args:
        n - Number of zeros.
        m - Bessel order.
        r - Radius.
        phi - Angle.
        knm - Corresponding k Fourier mode for n and m.
        Nnm - Corresponding normalisation constant.
    """
    Phi_m = get_Phi_m(m, phi)
    Rnm = get_Rnm(r, m, knm, Nnm)
    breakpoint()
    Psi_nm = Phi_m * Rnm

    return Psi_nm

class DiskHarmonics(HarmonicFunction):
    def __init__(
        self,
        radial_frequency: int,
        angular_frequency: int,
        max_radius: float,
        num_radii: int=None,
        num_phi: int=None,
        boundary: str="zero"
    ):
        super().__init__()

        self.radial_frequency = radial_frequency
        self.angular_frequency = angular_frequency
        self.max_radius = max_radius
        self.num_radii = num_radii
        self.num_phi = num_phi
        self.boundary = boundary

        self.basis_fns = nn.Parameter(self.generate_basis_fns(), requires_grad=False)

    def generate_basis_fns(self) -> torch.Tensor:
        self.p2d, self.r2d = grid.polargrid(self.max_radius, self.num_radii, self.num_phi)
        self.dr = self.r2d[0][1] - self.r2d[0][0]
        self.dphi = self.p2d[1][0] - self.p2d[0][0]
        self.m = get_m(self.angular_frequency)
        self.n = get_n(self.radial_frequency)
        self.m2d, self.n2d = np.meshgrid(self.m, self.n, indexing='ij')

        self.xnm = np.zeros(np.shape(self.m2d))
        self.knm = np.zeros(np.shape(self.m2d))
        self.Nnm = np.zeros(np.shape(self.m2d))

        len_m = len(self.m2d)
        for i in range(len_m // 2 + 1):
            mval = self.m[i]
            nval = self.n[-1]
            if self.boundary == "zero":
                xnm = bessel.get_Jm_zeros(mval, nval)
                knm = get_knm(xnm, self.max_radius)
                Nnm = get_Nnm_zero(mval, xnm, self.max_radius)
            else:
                xnm = bessel.get_dJm_zeros(mval, nval)
                knm = get_knm(xnm, self.max_radius)
                Nnm = get_Nnm_deri(mval, xnm, self.max_radius)

            self.xnm[i] = xnm
            self.knm[i] = knm
            self.Nnm[i] = Nnm

            if i != len_m-i and i != 0:
                self.xnm[len_m-i] = xnm
                self.knm[len_m-i] = knm
                self.Nnm[len_m-i] = Nnm

        self.m2d_flat = np.copy(self.m2d).flatten()
        self.n2d_flat = np.copy(self.n2d).flatten()
        self.xnm_flat = np.copy(self.xnm).flatten()
        self.knm_flat = np.copy(self.knm).flatten()
        self.Nnm_flat = np.copy(self.Nnm).flatten()

        self.Psi = np.zeros((self.radial_frequency * (self.angular_frequency*2+1),) + np.shape(self.r2d))
        self.Psi[0] = get_Psi_nm(self.n2d_flat[0], self.m2d_flat[0], self.r2d, self.p2d, self.knm_flat[0], self.Nnm.flat[0])
        for i in range(1, len(self.Psi), 2):
            breakpoint()
            self.Psi[i] = get_Psi_nm(self.n2d_flat[i], self.m2d_flat[i], self.r2d, self.p2d, self.knm_flat[i], self.Nnm.flat[i])
            self.Psi[i+1] = get_Psi_nm(self.n2d_flat[i], self.m2d_flat[i], self.r2d, self.p2d, self.knm_flat[i], self.Nnm.flat[i])

    def evaluate(
        self,
        coeffs: torch.Tensor,
        radii: torch.Tensor=None,
        phis: torch.Tensor=None
    ) -> torch.Tensor:
        if radii is not None:
            basis_fns = self.generate_basis_fns(radii, phis)
            return torch.einsum("inm,inm->i", coeffs, basis_fns.permute(2,0,1))
        else:
            return torch.einsum("inm,tnm->it", coeffs, self.basis_fns.permute(2,0,1))

